/**
 * Template merging service with smart deduplication
 */

/**
 * Generate a header for the merged instructions file
 * @param {Array} templates - Array of template objects that were merged
 * @returns {string} Header content
 */
function generateHeader(templates) {
  const templateNames = templates.map(t => t.name).join(', ');
  const timestamp = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
  
  return `<!-- 
This copilot-instructions.md file was generated by the Copilot Instructions Generator
Generated on: ${timestamp}
Source templates: ${templateNames}
Total templates merged: ${templates.length}

Source repository: https://github.com/github/awesome-copilot/tree/main/instructions
Generator: https://github.com/timheuer/ghcp-instructions
-->

# Copilot Instructions

This file contains merged instructions from multiple templates to provide comprehensive guidance for GitHub Copilot.

## Source Templates
${templates.map(t => `- **${t.name}** (${t.fileName})`).join('\n')}

---
`;
}

/**
 * Parse YAML front-matter from content
 * @param {string} content - Markdown content to parse
 * @returns {Object} Object with frontMatter and contentWithoutFrontMatter
 */
function parseFrontMatter(content) {
  const lines = content.split('\n');
  let frontMatter = null;
  let contentStart = 0;
  
  // Check if content starts with front-matter
  if (lines[0] && lines[0].trim() === '---') {
    let frontMatterEnd = -1;
    for (let i = 1; i < lines.length; i++) {
      if (lines[i] && lines[i].trim() === '---') {
        frontMatterEnd = i;
        break;
      }
    }
    
    if (frontMatterEnd > 0) {
      const frontMatterLines = lines.slice(1, frontMatterEnd);
      frontMatter = {};
      
      // Simple YAML parsing for description and appliesTo
      for (const line of frontMatterLines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('description:')) {
          const value = trimmed.substring('description:'.length).trim();
          frontMatter.description = value.replace(/^["']|["']$/g, ''); // Remove quotes
        } else if (trimmed.startsWith('appliesTo:')) {
          const value = trimmed.substring('appliesTo:'.length).trim();
          if (value.startsWith('[') && value.endsWith(']')) {
            // Parse array format
            const arrayContent = value.slice(1, -1);
            frontMatter.appliesTo = arrayContent.split(',').map(item => 
              item.trim().replace(/^["']|["']$/g, '')
            ).filter(item => item.length > 0);
          }
        }
      }
      
      contentStart = frontMatterEnd + 1;
    }
  }
  
  const contentWithoutFrontMatter = lines.slice(contentStart).join('\n');
  
  return {
    frontMatter,
    contentWithoutFrontMatter
  };
}

/**
 * Parse markdown content into sections
 * @param {string} content - Markdown content to parse
 * @returns {Array} Array of section objects with title, level, and content
 */
function parseMarkdownSections(content) {
  const lines = content.split('\n');
  const sections = [];
  let currentSection = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const headerMatch = line.match(/^(#{1,6})\s+(.+)$/);
    
    if (headerMatch) {
      // Save previous section if it exists
      if (currentSection) {
        sections.push(currentSection);
      }
      
      // Start new section
      currentSection = {
        level: headerMatch[1].length,
        title: headerMatch[2].trim(),
        content: [line],
        hash: generateSectionHash(headerMatch[2].trim())
      };
    } else if (currentSection) {
      // Add line to current section
      currentSection.content.push(line);
    } else {
      // Content before first header (skip front-matter processing here)
      if (line.trim()) {
        if (!sections.find(s => s.title === 'Preamble')) {
          sections.push({
            level: 0,
            title: 'Preamble',
            content: [line],
            hash: generateSectionHash('Preamble')
          });
        } else {
          const preamble = sections.find(s => s.title === 'Preamble');
          preamble.content.push(line);
        }
      }
    }
  }
  
  // Add final section
  if (currentSection) {
    sections.push(currentSection);
  }
  
  return sections;
}

/**
 * Generate a hash for a section title for comparison
 * @param {string} title - Section title
 * @returns {string} Normalized hash
 */
function generateSectionHash(title) {
  return title
    .toLowerCase()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, '-')
    .trim();
}

/**
 * Check if a section is a duplicate of existing sections
 * @param {Object} section - Section to check
 * @param {Array} existingSections - Array of existing sections
 * @returns {boolean} True if section is a duplicate
 */
function isDuplicateSection(section, existingSections) {
  // Check for exact title matches
  const exactMatch = existingSections.find(existing => 
    existing.hash === section.hash
  );
  
  if (exactMatch) {
    // Check content similarity for exact title matches
    const similarity = calculateContentSimilarity(
      section.content.join('\n'),
      exactMatch.content.join('\n')
    );
    
    // If content is very similar (>80%), consider it a duplicate
    return similarity > 0.8;
  }
  
  // Check for common generic sections that should be merged
  const genericSections = [
    'instructions',
    'rules',
    'guidelines',
    'best-practices',
    'coding-standards',
    'requirements'
  ];
  
  const isGeneric = genericSections.some(generic => 
    section.hash.includes(generic) || generic.includes(section.hash)
  );
  
  if (isGeneric) {
    const similarSection = existingSections.find(existing =>
      genericSections.some(generic => 
        (existing.hash.includes(generic) || generic.includes(existing.hash)) &&
        existing.level === section.level
      )
    );
    
    if (similarSection) {
      // Merge content instead of duplicating
      const uniqueLines = section.content.filter(line =>
        !similarSection.content.some(existingLine =>
          line.trim() === existingLine.trim()
        )
      );
      
      if (uniqueLines.length > 1) { // More than just the header
        similarSection.content = [...similarSection.content, ...uniqueLines.slice(1)];
      }
      
      return true; // Mark as duplicate since we merged it
    }
  }
  
  return false;
}

/**
 * Calculate content similarity between two strings
 * @param {string} content1 - First content string
 * @param {string} content2 - Second content string
 * @returns {number} Similarity score between 0 and 1
 */
function calculateContentSimilarity(content1, content2) {
  const normalize = (str) => str
    .toLowerCase()
    .replace(/[^\w\s]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
  
  const norm1 = normalize(content1);
  const norm2 = normalize(content2);
  
  if (norm1 === norm2) return 1;
  if (norm1.length === 0 && norm2.length === 0) return 1;
  if (norm1.length === 0 || norm2.length === 0) return 0;
  
  // Simple word-based similarity
  const words1 = norm1.split(' ');
  const words2 = norm2.split(' ');
  const allWords = new Set([...words1, ...words2]);
  
  let commonWords = 0;
  for (const word of allWords) {
    if (words1.includes(word) && words2.includes(word)) {
      commonWords++;
    }
  }
  
  return (2 * commonWords) / (words1.length + words2.length);
}

/**
 * Merge multiple template contents into a single instruction file
 * @param {Array} templates - Array of template objects
 * @param {Array} contents - Array of template content strings
 * @returns {string} Merged instruction content
 */
export function mergeTemplates(templates, contents) {
  if (templates.length !== contents.length) {
    throw new Error('Templates and contents arrays must have the same length');
  }
  
  const allSections = [];
  const collectedFrontMatter = [];
  
  // Add main title section at the top
  allSections.push({
    level: 1,
    title: 'Copilot Instructions',
    content: ['# Copilot Instructions', '', '', ''],
    hash: 'copilot-instructions',
    isMainTitle: true
  });
  
  // Process each template
  contents.forEach((content, index) => {
    const template = templates[index];
    console.log(`Processing template: ${template.name}`);
    
    // Parse front-matter from content
    const { frontMatter, contentWithoutFrontMatter } = parseFrontMatter(content);
    
    // Collect front-matter for potential merging
    if (frontMatter) {
      collectedFrontMatter.push({
        template: template.name,
        ...frontMatter
      });
    }
    
    // Parse sections from content without front-matter
    const sections = parseMarkdownSections(contentWithoutFrontMatter);
    
    // Add template header
    allSections.push({
      level: 2,
      title: `Instructions from: ${template.name}`,
      content: [''],
      hash: `instructions-from-${template.name.toLowerCase()}`,
      isTemplateHeader: true
    });
    
    // Add sections with deduplication
    sections.forEach(section => {
      if (!isDuplicateSection(section, allSections)) {
        allSections.push(section);
      }
    });
    
    // Add spacing between templates
    allSections.push({
      level: 0,
      title: 'Spacing',
      content: [''],
      hash: `spacing-${index}`,
      isSpacing: true
    });
  });
  

  
  // Convert sections back to markdown
  const mergedContent = allSections
    .map(section => section.content.join('\n'))
    .join('\n');
  
  // Clean up excessive empty lines
  const cleanedContent = mergedContent
    .replace(/\n{4,}/g, '\n\n\n')
    .trim();
  
  // Return content without any footer information
  return cleanedContent;
}

/**
 * Generate statistics about the merge operation
 * @param {Array} templates - Array of template objects that were merged
 * @param {string} mergedContent - The final merged content
 * @returns {Object} Statistics object
 */
export function generateMergeStats(templates, mergedContent) {
  const lines = mergedContent.split('\n').length;
  const words = mergedContent.split(/\s+/).filter(word => word.length > 0).length;
  const characters = mergedContent.length;
  
  return {
    templateCount: templates.length,
    templates: templates.map(t => t.name),
    outputStats: {
      lines,
      words,
      characters,
      estimatedReadingTime: Math.ceil(words / 200) // Assume 200 words per minute
    },
    generatedAt: new Date().toISOString()
  };
}
